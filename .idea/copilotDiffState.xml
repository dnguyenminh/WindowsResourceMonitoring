<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/scripts/monitor_processes.ps1">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/monitor_processes.ps1" />
              <option name="originalContent" value="Unregister-Event -SourceIdentifier ProcessMonitor&#10;# monitor_processes.ps1&#10;$OutputFile = &quot;C:\Temp\process_alerts.txt&quot;&#10;$CPUThreshold = 1&#10;$MemoryThreshold = 10000 # ~10 KB for easier testing&#10;$Query = @&quot;&#10;SELECT * FROM __InstanceModificationEvent WITHIN 1&#10;WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfProc_Process'&#10;AND (TargetInstance.PercentProcessorTime &gt; $CPUThreshold OR TargetInstance.WorkingSet &gt; $MemoryThreshold)&#10;&quot;@&#10;&#10;Write-Output &quot;Starting process monitor script...&quot;&#10;Write-Output &quot;Query: $Query&quot;&#10;&#10;# Ensure output directory exists&#10;$OutputDir = Split-Path $OutputFile -Parent&#10;if (-not (Test-Path $OutputDir)) {&#10;    New-Item -ItemType Directory -Path $OutputDir | Out-Null&#10;}&#10;# Ensure output file exists at startup&#10;if (-not (Test-Path $OutputFile)) {&#10;    New-Item -Path $OutputFile -ItemType File -Force | Out-Null&#10;}&#10;&#10;Write-Output &quot;Registering WMI event...&quot;&#10;&#10;# Register WMI event&#10;Register-WmiEvent -Query $Query -SourceIdentifier &quot;ProcessMonitor&quot; -Action {&#10;    Write-Output &quot;Event action triggered!&quot; # Debug log&#10;    try {&#10;        $Event = $EventArgs.NewEvent.TargetInstance&#10;        $ProcessName = $Event.Name&#10;        $PID = $Event.IDProcess&#10;        $CPUUsage = $Event.PercentProcessorTime&#10;        $MemoryUsage = $Event.WorkingSet&#10;        $Timestamp = Get-Date -Format &quot;yyyy-MM-dd HH:mm:ss&quot;&#10;&#10;        $Message = &quot;[$Timestamp] Process: $ProcessName (PID: $PID), CPU: $CPUUsage%, Memory: $($MemoryUsage / 1048576) MB&quot;&#10;        Write-Output &quot;Alert: $Message&quot;&#10;        Add-Content -Path $OutputFile -Value $Message&#10;    } catch {&#10;        Write-Output &quot;Error in event action: $_&quot;&#10;        Add-Content -Path $OutputFile -Value &quot;[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')] Error: $_&quot;&#10;    }&#10;}&#10;Write-Output &quot;WMI event registered. Waiting for events...&quot;&#10;&#10;# Keep the script running to process events&#10;while ($true) {&#10;    $Timestamp = Get-Date -Format &quot;yyyy-MM-dd HH:mm:ss&quot;&#10;    Write-Output &quot;Wait at: $Timestamp&quot;&#10;    Start-Sleep -Seconds 5&#10;}&#10;" />
              <option name="updatedContent" value="Unregister-Event -SourceIdentifier ProcessMonitor&#10;# monitor_processes.ps1&#10;$OutputFile = &quot;C:\Temp\process_alerts.txt&quot;&#10;$CPUThreshold = 1&#10;$MemoryThreshold = 10000 # ~10 KB for easier testing&#10;$Query = @&quot;&#10;SELECT * FROM __InstanceModificationEvent WITHIN 1&#10;WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfProc_Process'&#10;AND (TargetInstance.PercentProcessorTime &gt; $CPUThreshold OR TargetInstance.WorkingSet &gt; $MemoryThreshold)&#10;&quot;@&#10;&#10;Write-Output &quot;Starting process monitor script...&quot;&#10;Write-Output &quot;Query: $Query&quot;&#10;&#10;# Ensure output directory exists&#10;$OutputDir = Split-Path $OutputFile -Parent&#10;if (-not (Test-Path $OutputDir)) {&#10;    New-Item -ItemType Directory -Path $OutputDir | Out-Null&#10;}&#10;# Ensure output file exists at startup&#10;if (-not (Test-Path $OutputFile)) {&#10;    New-Item -Path $OutputFile -ItemType File -Force | Out-Null&#10;}&#10;&#10;Write-Output &quot;Registering WMI event...&quot;&#10;&#10;# Register WMI event&#10;Register-WmiEvent -Query $Query -SourceIdentifier &quot;ProcessMonitor&quot; -Action {&#10;    Write-Output &quot;Event action triggered!&quot; # Debug log&#10;    try {&#10;        $Event = $EventArgs.NewEvent.TargetInstance&#10;        $ProcessName = $Event.Name&#10;        $PID = $Event.IDProcess&#10;        $CPUUsage = $Event.PercentProcessorTime&#10;        $MemoryUsage = $Event.WorkingSet&#10;        $Timestamp = Get-Date -Format &quot;yyyy-MM-dd HH:mm:ss&quot;&#10;&#10;        $Message = &quot;[$Timestamp] Process: $ProcessName (PID: $PID), CPU: $CPUUsage%, Memory: $($MemoryUsage / 1048576) MB&quot;&#10;        Write-Output &quot;Alert: $Message&quot;&#10;        Add-Content -Path $OutputFile -Value $Message&#10;    } catch {&#10;        Write-Output &quot;Error in event action: $_&quot;&#10;        Add-Content -Path $OutputFile -Value &quot;[$(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')] Error: $_&quot;&#10;    }&#10;}&#10;Write-Output &quot;WMI event registered. Waiting for events...&quot;&#10;&#10;# Diagnostic: Output job status and registered events&#10;$job = Get-Job | Where-Object { $_.Name -eq 'ProcessMonitor' }&#10;if ($job) {&#10;    Write-Output &quot;Job status: $($job.State)&quot;&#10;} else {&#10;    Write-Output &quot;No job found with name 'ProcessMonitor'&quot;&#10;}&#10;&#10;$events = Get-EventSubscriber | Where-Object { $_.SourceIdentifier -eq 'ProcessMonitor' }&#10;Write-Output &quot;Registered event subscribers: $($events.Count)&quot;&#10;foreach ($evt in $events) {&#10;    Write-Output &quot;EventSubscriber: $($evt.SourceIdentifier), Action: $($evt.Action)&quot;&#10;}&#10;&#10;# Keep the script running to process events&#10;while ($true) {&#10;    $Timestamp = Get-Date -Format &quot;yyyy-MM-dd HH:mm:ss&quot;&#10;    Write-Output &quot;Wait at: $Timestamp&quot;&#10;    Start-Sleep -Seconds 5&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>